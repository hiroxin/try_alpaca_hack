# 2026/02/21 問題

https://alpacahack.com/daily/challenges/copper-copper-copper

## 問題文

```
Look! An alpaca! C(・´(ェ)｀・)u
```

## 考察

予告通り RSA 暗号の解読問題

```
p = getPrime(512)
q = getPrime(512)
N = p * q
e = 65537

m = bytes_to_long(FLAG.encode())
c = pow(m, e, N)
```

材料を用意し、 `m^e (mod N)` で暗号化

ちなみに `m = bytes_to_long(FLAG.encode())` は FLAG をバイト列に変換して、 long 型に変換している。

`pbar = p & (~((1 << KBITS) - 1))` について

- `(1 << KBITS)` は 1 を `KBITS` (200) ビット左シフトさせる。つまり、 `1 << 200` は `2^200` になる。
- `(1 << KBITS) - 1` は単に `2^200` から `1` を引いた値
- `~((1 << KBITS) - 1)` は `2^200 - 1` のビット反転させた値
  - 今回の場合、 `(1 << KIBITS) -1` は 200 ビットが 1 で埋まっているので、それをビット反転させると 200 ビットが 0 で埋まった値となる
- `p & (~((1 << KBITS) - 1))`
  - `&` で論理積をとっている
    - `p` は 512 ビットの素数なので、 `p` の下位 200 ビットが 0 になり、上位 312 ビットがそのまま残った値となる

これは数学的には `⌊​p/2^KBITS⌋ * 2^KBITS` と表すことができる。 `⌊​x⌋` は床関数 (ガウス記号) と同義で、 `x` を超えない最大の整数を表す。

手元にある `p` の一部と、不明な下位 `KBITS` から `p` を推測し、そこから `m` を復号する。

`p` の上位ビット(半分以上)が判明している状態から `p` を特定するには、 Coppersmith's Attack を用いる。 CTF では定番らしい。

Coppersmith's Attack とは、全体像 `N` が分かっており、さらにそれを構成する素数のある程度の部分が明らかになっている場合に、その一部を用いて `p` を特定する攻撃手法である。数学的には「多項式の小さな根（Small Roots of Polynomials）を見つける問題」に置き換えて考えられる。

詳細は割愛するが、LLLアルゴリズムを用いると計算ができるらしい。手計算では困難。

以下の順に処理を行うスクリプト `decrypt.py` を作成する

- `pbar` と `KBITS` から `p` を特定
- `p` と `N` から `q` を特定
- `pow(e, -1, λ(N))` で `d` を計算
  - `d` は `λ(N)` における `e` のモジュラ逆元であり、 `d*e ≡ 1 (mod λ(N))` が成り立つため
- `pow(c, d, N)` で `m` を復元
  - `c ≡ m^e (mod N)` → `c^d ≡ m (mod N)` より
- `m` をバイト列、文字列の順に変換して FLAG を復元

## 解答

```
$ python3 2026-02/02-21_crypto/decrypt.py
Alpaca{Th3_C0pp3r5m17h_m37h0d_w45_pr0p053d_by_D0n_C0pp3r5m17h:)}
```

## 参考

### `c = m^e (mod N)` の解読に `p`, `q` が必要なのか？

暗号文 `c` から平文 `m` を取り出すには、以下を満たす `d` が必要

```
m ≡ c^d (mod N)
```

この `d` を計算する際に `λ(N)` (カーマイケル関数)、 `φ(N)` (オイラーのトーシェント関数) が必要になる。

`d` は以下の条件を満たすように作られる。この時 `d` は 法 `λ(N)` における `e` のモジュラ逆元と呼ばれる。

```
e * d ≡ 1 (mod λ(N))
```

`λ(N)` (カーマイケル関数)は `N` の最小公倍数を求める関数、`φ(N)` (オイラーのトーシェント関数) は `N` の約数の個数を求める関数であり、それぞれと表す。

```
λ(N) = lcm(λ(p1), λ(p2), ..., λ(pn))
```

```
φ(N) = N * (1 - 1/p1) * (1 - 1/p2) * ... * (1 - 1/pn)
```

ここで `p1, p2, ..., pn` は `N` の素因数分解の結果の素数

今回の RSA 問題の場合、

```
λ(N) = lcm(λ(p1), λ(p2), ..., λ(pn))
     = lcm(λ(p), λ(q))
     = lcm(p-1, q-1) ····(*)
```

(\*) `p` は素数なので `λ(p) = p-1` となる。詳細はフェルマーの小定理などを参照

`φ(N)` については

```
φ(N) = N * (1 - 1/p1) * (1 - 1/p2) * ... * (1 - 1/pn)
     = p * q * (1 - 1/p) * (1 - 1/q)
     = p * q * (p-1)/p * (q-1)/q
     = (p-1) * (q-1)
```

#### (余談) なぜ `λ(N)` を使うと `m` が復元できるのか？

カーマイケルの定理では、 `m` と `N` が互いに素であるとき、以下の式が成り立つ。

```
m^λ(N) ≡ 1 (mod N)
```

先ほど `d` は `e * d ≡ 1 (mod λ(N))` となるように定義した。これは整数 `k` を用いて変換すると

```
e * d = k * λ(N) + 1
```

となる。これらを使って `c^d` を変形していくと `c^d ≡ m (mod N)` が得られる。

```
c^d = (m^e)^d
    = m^(e * d)
    = m^(k * λ(N) + 1)
    = (m^λ(N))^k * m
    ≡ 1^k * m (mod N) ····(**)
    ≡ m (mod N)
```

つまり

- `d ≡ e^-1 (mod λ(N))` → `d = pow(e, -1, λ(N))`
- `m ≡ c^d (mod N)` → `m = pow(c, d, N)`

で `m` が復元できる。

(\*\*) 前述のカーマイケルの定理 ( `m^λ(N) ≡ 1 (mod N)` )より。　RSA 暗号において、ほとんどの場合 `m` と `N` は互いに素になる。もし `m` が `p` や `q` の倍数であっても、 Chinese Remainder Theorem (CRT) によって `m^ed ≡ m (mod N)` が成り立つ。

### `d ≡ e^-1 (mod λ(N))` と `m ≡ c^d (mod N)` でなぜ元の FLAG が復元できるのか？

合同式である以上、 d, m は `k*λ(N)` , `k*N` だけずれる可能性がある。特に後者がずれた場合、平文を復元できなくなるはずだが、問題ないのか調査。

### `d ≡ e^-1 (mod λ(N))` について

これは `m` と `N` が互いに素であるときに成り立つ、カーマイケルの定理 `m^λ(N) ≡ 1 (mod N)` が効いてくる。

もし `d` から `k*λ(N)` ずれた `d'` で暗号文 `c` を復号したとしても

```
c^d' = (m^e)^d'
     = m^(e * (d + k*λ(N)))
     = m^(e * d) * m^(k*λ(N))
     ≡ m^(e * d) * 1^k (mod N)
     = m^(e * d)
     = m
```

となり、`d'` でも `m` が復元できる。

### `m ≡ c^d (mod N)` について

こちらは数学的には上記を満たす候補は無限に存在する。 ( ... `m-N`, `m`, `m+N`, `m+2N`, ... )

このままでは元の平文メッセージが壊れるリスクがあるが、ここで RSA 暗号のルールが効いてくる。
RSA 暗号では、暗号化する前に「元のメッセージ `m` は `0 <= m < N` でなければならない」と言う厳格なルールがある。

また、プログラムで復号の計算 ( `pow(c, d, N)` ) は必ず `0 <= x <N` を満たす `x` を返す。 \
つまり、数学的に `m ≡ c^d (mod N)` を満たす候補が無数にあったとしても、RSA 暗号においては一意に定まる。
