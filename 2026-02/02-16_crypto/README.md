# 2026/02/16 問題

https://alpacahack.com/daily/challenges/alpaillier

## 問題文

```
Who is Alpaillier?
```

## 考察

暗号化スクリプトの読解

1. 512 ビットのランダムな素数を２つ生成
2. ２つの素数を掛け合わせて公開鍵 `n`, を作成する。公開鍵 `n` をもとに `g =n+1` を生成する。
3. `n` と素である乱数 `r (2 <= r <= n-1)` を生成
4. `r^n (mod n^2)` を生成
5. FLAG の中身を一文字ずつ暗号化する
6. 公開鍵 `n` と暗号化した FLAG を出力する

これを Paillier 暗号と言うらしい。今回はこれを復号する

## 解答

公開鍵 `n` をもとに復号を進める \
とはいえ、 `c = (pow(g, b, n2) * rn) % n2` の剰余算の逆算は一意に定まらない \
FLAG が `Alpaca{}` であることから、メタ読みも可能だがアシストを受けながら正攻法で解く

Paillier の暗号式は `c = g^b * r^n (mod n^2)`

i 番目の文字の暗号化式は　`c_{i} = g^b_{i} * r^n (mod n^2)` になる

- `c_{i}` : 既知。 i 番目の暗号化された文字
- `g` : 既知。公開鍵 `n` に `1` を足した値
- `b_{i}` : 未知。平文の i 番目の文字
- `r` : 未知。公開鍵 `n` と素な整数。ただし、任意の i で値は共通

このとき、 `c_{i}` と `c_{0}` で比をとると

```
c_{i} / c_{0} ≡ ( g^b_{i} * r^n ) / ( g^b_{0} * r^n ) (mod n^2)
              = g^( b_{i} - b_{0} ) (mod n^2)
```

ここで得られた結果を `d_{i} = g^( b_{i} - b_{0} ) (mod n^2)` とする。

Paillier で `g = n+1` のとき、任意の整数 k について `(n+1)^k ≡ 1 + kn  (mod n^2)` が成り立つ。詳細は割愛。二項定理から求められる

```
(n+1)^k ≡ 1 + kn (mod n^2)
→ (n+1)^k - 1 ≡ kn (mod n^2)
→ ( (n+1)^k - 1 )/ n ≡ k  (mod n^2)
```

これは Pailllier 関数のお約束関数と呼ばれ `L(x) = (x-1)/n` で表される

先ほどの `d_{i} = g^( b_{i} - b_{0} ) (mod n^2)` について、お約束関数を用いると

```
L(d_{i}) = ( d_{i} - 1 )/n
         = ( g^(b_{i} - b{0}) -1 )/n (mod n^2)
```

これは `((n+1)^k - 1)/ n ≡ k (mod n^2)` の

- `n+1` = `g`
- `k` = `b_{i} - b_{0}`

に置き換えた形なので

```
delta_i := L(d_{i}) = b_{i} - b_{0} (mod n^2)
```

となる。

### `b_i` が 1 バイトであることの確認

`chall.py` の 20 行目を見ると：

```python
for b in flag:
```

ここで `flag` は 5 行目で `.encode()` されているので `bytes` 型。
Python で `for b in bytes型:` とすると、`b` は各バイト（0〜255 の整数）になる。

したがって、**`b_i` は 0〜255 の範囲の整数**として確定する。

### `delta_i` の計算方法

実装では：

```python
d_i = (c_i * pow(c0, -1, n2)) % n2
delta_i = (d_i - 1) // n
```

`d_i` は `0 <= d_i < n^2` の整数として手元にある。
`g = n+1` の性質から `d_i = 1 + (b_i - b_0) * n` が成り立つので、
`(d_i - 1) // n` がそのまま `b_i - b_0` になる。

ただし、`b_i - b_0` は -255 〜 255 の範囲だが、`delta_i` がこの範囲外になる場合がある。
その場合は `delta_i -= n` などで調整して、-255 〜 255 程度の範囲に正規化する。

### `b_0` を総当たりして平文を復元

`delta_i = b_i - b_0` は既知だが、`b_0` 自体はまだ未知。

しかし `b_i` は 0〜255 の範囲なので：

1. `b_0` を 0〜255 で総当たり
2. 各候補 `b_0` について `b_i = b_0 + delta_i` を計算
3. どれかの `b_i` が 0〜255 の範囲外になったら、その `b_0` は却下
4. 全ての `b_i` が 0〜255 に収まる候補だけ残す
5. 残った候補列を `bytes([b_0, b_1, ...])` にして、**自然な ASCII 文字列**になっているものを選ぶ

通常は、まともな ASCII 文字列になる候補は 1 つだけになるので、
`Alpaca{}` というメタ情報がなくても、この総当たりで一意にフラグを決められる。

解答: `Alpaca{th3_p4st3l_4lp4c4_is_pl4cid}`

## 参考

- `getPrime(a)` : 指定したサイズ (`a` バイト) のランダムな整数を生成する
- `GCD(x, y)` : `x` と `y` の最大公約数を求める
- `pow(b, e, m)` : `b^e (mod m)` を行う
  - `b^e` を計算してから `m` の合同数を求めるより高速でメモリ消費量が少ない
  - 暗号技術的には `pow(r, n, n^2)` は Pailller 暗号の乱数成分の作成にあたる
    - Pailler 暗号: `c = g^m * r^n (mod n^2)`
      - `m` : 平文 (メッセージ)
      - `g` : 公開鍵の一部 (ベース)
      - `n` : 公開鍵 ( `p*q` )
      - `r` : ランダムな値。ここが都度変わるので攻撃者による平文の推測を防ぐ
